// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: cost.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkInsertCost = `-- name: BulkInsertCost :exec
INSERT INTO
    costs (
        cost_id,
        baseline_id,
        cost_type,
        description,
        comment,
        amount,
        currency,
        tax,
        apply_inflation,
        created_at
    )
VALUES (
        unnest($1::text []),
        unnest($2::text []),
        unnest($3::text []),
        unnest($4::text []),
        unnest($5::text []),
        unnest($6::float8[]),
        unnest($7::text []),
        unnest($8::float8[]),
        unnest($9::boolean[]),
        unnest($10::timestamp[])
    )
`

type BulkInsertCostParams struct {
	Column1  []string
	Column2  []string
	Column3  []string
	Column4  []string
	Column5  []string
	Column6  []float64
	Column7  []string
	Column8  []float64
	Column9  []bool
	Column10 []pgtype.Timestamp
}

func (q *Queries) BulkInsertCost(ctx context.Context, arg BulkInsertCostParams) error {
	_, err := q.db.Exec(ctx, bulkInsertCost,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Column10,
	)
	return err
}

const bulkInsertCostAllocation = `-- name: BulkInsertCostAllocation :exec
INSERT INTO
    cost_allocations (
        cost_allocation_id,
        cost_id,
        allocation_date,
        amount,
        created_at
    )
VALUES (
        unnest($1::text []),
        unnest($2::text []),
        unnest($3::date[]),
        unnest($4::float8[]),
        unnest($5::timestamp[])
    )
`

type BulkInsertCostAllocationParams struct {
	Column1 []string
	Column2 []string
	Column3 []pgtype.Date
	Column4 []float64
	Column5 []pgtype.Timestamp
}

func (q *Queries) BulkInsertCostAllocation(ctx context.Context, arg BulkInsertCostAllocationParams) error {
	_, err := q.db.Exec(ctx, bulkInsertCostAllocation,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	return err
}

const deleteCost = `-- name: DeleteCost :one
DELETE FROM costs WHERE cost_id = $1 RETURNING cost_id, baseline_id, cost_type, description, comment, amount, currency, tax, apply_inflation, created_at, updated_at
`

func (q *Queries) DeleteCost(ctx context.Context, costID string) (Cost, error) {
	row := q.db.QueryRow(ctx, deleteCost, costID)
	var i Cost
	err := row.Scan(
		&i.CostID,
		&i.BaselineID,
		&i.CostType,
		&i.Description,
		&i.Comment,
		&i.Amount,
		&i.Currency,
		&i.Tax,
		&i.ApplyInflation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCostAllocations = `-- name: DeleteCostAllocations :execrows
DELETE FROM cost_allocations WHERE cost_id = $1
`

func (q *Queries) DeleteCostAllocations(ctx context.Context, costID string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteCostAllocations, costID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findCostAllocationsByCostId = `-- name: FindCostAllocationsByCostId :many
SELECT cost_allocation_id, cost_id, allocation_date, amount, created_at, updated_at
FROM cost_allocations
WHERE
    cost_id = $1
ORDER BY allocation_date ASC
`

func (q *Queries) FindCostAllocationsByCostId(ctx context.Context, costID string) ([]CostAllocation, error) {
	rows, err := q.db.Query(ctx, findCostAllocationsByCostId, costID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CostAllocation
	for rows.Next() {
		var i CostAllocation
		if err := rows.Scan(
			&i.CostAllocationID,
			&i.CostID,
			&i.AllocationDate,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findCostById = `-- name: FindCostById :one
SELECT cost_id, baseline_id, cost_type, description, comment, amount, currency, tax, apply_inflation, created_at, updated_at FROM costs WHERE cost_id = $1
`

func (q *Queries) FindCostById(ctx context.Context, costID string) (Cost, error) {
	row := q.db.QueryRow(ctx, findCostById, costID)
	var i Cost
	err := row.Scan(
		&i.CostID,
		&i.BaselineID,
		&i.CostType,
		&i.Description,
		&i.Comment,
		&i.Amount,
		&i.Currency,
		&i.Tax,
		&i.ApplyInflation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findCostsByBaselineId = `-- name: FindCostsByBaselineId :many
SELECT cost_id, baseline_id, cost_type, description, comment, amount, currency, tax, apply_inflation, created_at, updated_at
FROM costs
WHERE
    baseline_id = $1
ORDER BY cost_type, description ASC
`

func (q *Queries) FindCostsByBaselineId(ctx context.Context, baselineID string) ([]Cost, error) {
	rows, err := q.db.Query(ctx, findCostsByBaselineId, baselineID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cost
	for rows.Next() {
		var i Cost
		if err := rows.Scan(
			&i.CostID,
			&i.BaselineID,
			&i.CostType,
			&i.Description,
			&i.Comment,
			&i.Amount,
			&i.Currency,
			&i.Tax,
			&i.ApplyInflation,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCost = `-- name: InsertCost :exec
INSERT INTO
    costs (
        cost_id,
        baseline_id,
        cost_type,
        description,
        comment,
        amount,
        currency,
        tax,
        apply_inflation,
        created_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10
    )
`

type InsertCostParams struct {
	CostID         string
	BaselineID     string
	CostType       string
	Description    string
	Comment        pgtype.Text
	Amount         float64
	Currency       string
	Tax            float64
	ApplyInflation bool
	CreatedAt      pgtype.Timestamp
}

func (q *Queries) InsertCost(ctx context.Context, arg InsertCostParams) error {
	_, err := q.db.Exec(ctx, insertCost,
		arg.CostID,
		arg.BaselineID,
		arg.CostType,
		arg.Description,
		arg.Comment,
		arg.Amount,
		arg.Currency,
		arg.Tax,
		arg.ApplyInflation,
		arg.CreatedAt,
	)
	return err
}

const insertCostAllocation = `-- name: InsertCostAllocation :exec
INSERT INTO
    cost_allocations (
        cost_allocation_id,
        cost_id,
        allocation_date,
        amount,
        created_at
    )
VALUES ($1, $2, $3, $4, $5)
`

type InsertCostAllocationParams struct {
	CostAllocationID string
	CostID           string
	AllocationDate   pgtype.Date
	Amount           float64
	CreatedAt        pgtype.Timestamp
}

func (q *Queries) InsertCostAllocation(ctx context.Context, arg InsertCostAllocationParams) error {
	_, err := q.db.Exec(ctx, insertCostAllocation,
		arg.CostAllocationID,
		arg.CostID,
		arg.AllocationDate,
		arg.Amount,
		arg.CreatedAt,
	)
	return err
}

const updateCost = `-- name: UpdateCost :exec
UPDATE costs
SET
    baseline_id = $2,
    cost_type = $3,
    description = $4,
    comment = $5,
    amount = $6,
    currency = $7,
    tax = $8,
    apply_inflation = $9,
    updated_at = $10
WHERE
    cost_id = $1
`

type UpdateCostParams struct {
	CostID         string
	BaselineID     string
	CostType       string
	Description    string
	Comment        pgtype.Text
	Amount         float64
	Currency       string
	Tax            float64
	ApplyInflation bool
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) UpdateCost(ctx context.Context, arg UpdateCostParams) error {
	_, err := q.db.Exec(ctx, updateCost,
		arg.CostID,
		arg.BaselineID,
		arg.CostType,
		arg.Description,
		arg.Comment,
		arg.Amount,
		arg.Currency,
		arg.Tax,
		arg.ApplyInflation,
		arg.UpdatedAt,
	)
	return err
}
